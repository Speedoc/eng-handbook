# Coding & Testing

### Level 1
<ul>
  <li>Learns to write correct code, following guidance and training materials.</li>
  <li>Writes code with support from more senior engineers.</li>
  <li>Responds to PR comments and makes the necessary changes.</li>
  <li>Writes tests with adequate coverage with assistance of others.</li>
  <li>Tries to debug issues with own code understand why things don't work before asking for help.</li>
</ul>

### Level 2
<ul>
  <li>Able to use follow established design patterns and techniques.</li>
  <li>Writes clean idiomatic code adhering to chapter coding standards.</li>
  <li>Adds appropriate logging and monitoring needed to help with debugging.</li>
  <li>Writes tests with adequate coverage, independently.
</li>
</ul>

### Level 3
<ul>
  <li>Owns the implementation of the solution to their assigned task.</li>
  <li>Code is easy to understand, change, and maintain.</li>
  <li>Proactively improves components, modules, services, systems, and codebases they encounter.</li>
  <li>Adds domain specific metrics to help understand application performance.</li>
  <li>Considers and tests edge-cases.</li>
  <li>Spots opportunities to improve testing.</li>
  <li>Chooses the right data structure for what they are trying to solve.</li>
</ul>

### Level 4
<ul>
  <li>Spots inefficient or incorrect uses of the language or bad patterns.</li>
  <li>Implements changes within components, modules, services, systems, or codebases that require a deep level of domain knowledge.</li>
  <li>Writes code that serves as an example for other engineers.</li>
  <li>Applies appropriate testing methodologies when testing modules, services, systems, components.</li>
  <li>Understands and implements the most appropriate forms of test coverage for different scenarios.</li>
</ul>

### Level 5
<ul>
  <li>Makes major contributions to library code and core services, for example major refactoring that requires deep understanding of the systems.</li>
  <li>Detailed knowledge of the core libraries or APIs for their primary language.</li>
  <li>Implements distributed systems consisting of multiple interacting services, or reusable core modules that are consumable for different use cases.</li>
  <li>Considers the necessity of and acts on wider non-functional testing such as performance testing, application memory tuning, frontend profiling, pen testing.</li>
</ul>

### Level 6
<ul>
  <li>Go-to person for any queries about their language or area of the codebase.</li>
  <li>Keeps up to date with the latest language versions and what they offer, applies this where appropriate.</li>
  <li>Mentors the squad and chapter on best practices about their language, latest updates & versions, coding styles.</li>
  <li>Makes major contributions to testing across multiple applications and their connecting technologies, identifies bottlenecks.</li>
  <li>Helps introduce new frameworks, languages, tools, drives adoption of them when suitable.</li>
  <li>Breaks down the most complicated technical problems and solves them quickly and autonomously.</li>
  <li>Drives the overall chapter's testing architecture to test complex flows. Uses non-functional testing tools.</li>
</ul>

### Level 7
<ul>
  <li>Contributes to external technologies or libraries that we depend on, such as opening issues, contributing to active discussions + issues, in the course of solving real business problems.</li>
  <li>Can jump into others complex coding challenges and is able to quickly understand the context and offer solutions.</li>
  <li>Makes improvements to the stability or performance of the entire platform.</li>
  <li>Has a breadth of knowledge across a range of languages/technologies in different paradigms (e.g. Object-Oriented / Functional) and an ability to rapidly grasp the key concepts in ones which you are unfamiliar with.</li>
  <li>Quickly embraces new languages and helps others understand them.</li>
</ul>